<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain Editor</title>
    <style>
        /* General styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #111;
            z-index: 1;
        }

        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: #2a2a2a;
            border-left: 1px solid #444;
            overflow-y: auto;
            z-index: 10;
        }

        .section {
            margin: 15px;
            background: #333;
            border-radius: 8px;
            padding: 15px;
        }

        .section h3 {
            margin-bottom: 15px;
            color: #4a9eff;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: #555;
            border-radius: 3px;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
        }

        .control-group input[type="number"], .control-group select {
            width: 100%;
            padding: 8px;
            background: #444;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
        }

        .control-group input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .btn {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin: 5px 5px 5px 0;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #3a8eef;
            transform: translateY(-1px);
        }

        .btn.active {
            background: #ff6b35;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 11px;
        }

        .brush-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .brush-btn {
            padding: 15px;
            border: 2px solid #555;
            border-radius: 8px;
            background: #444;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 12px;
        }

        .brush-btn.active {
            border-color: #4a9eff;
            background: #4a9eff;
        }

        .brush-btn.black { border-left: 4px solid #000; }
        .brush-btn.red { border-left: 4px solid #ff0000; }
        .brush-btn.green { border-left: 4px solid #00ff00; }
        .brush-btn.blue { border-left: 4px solid #0000ff; }

        .layer-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin: 5px 0;
            background: #444;
            border-radius: 4px;
        }

        .layer-name {
            font-size: 12px;
        }

        .eye-btn {
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 16px;
            transition: color 0.2s;
        }

        .eye-btn:hover {
            color: #4a9eff;
        }

        .eye-btn.hidden {
            color: #666;
        }

        .texture-size-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: #333;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            min-width: 300px;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #4a9eff;
        }

        .size-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .size-option {
            padding: 15px;
            background: #444;
            border: 2px solid #555;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .size-option:hover {
            border-color: #4a9eff;
            background: #4a9eff;
        }

        .toolbar {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
        }

        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }

        .export-section {
            border-top: 1px solid #555;
            padding-top: 15px;
            margin-top: 15px;
        }

        .btn-export {
            background: #28a745;
            width: 100%;
            margin: 5px 0;
        }

        .btn-export:hover {
            background: #218838;
        }

        #canvas {
            display: block;
            width: 100vw !important;
            height: 100vh !important;
        }

        #brushRing {
            position: absolute;
            width: 30px; /* Fixed size */
            height: 30px; /* Fixed size */
            border: 2px solid rgba(255, 255, 255, 0.4); /* Adjust thickness */
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            display: none; /* Initially hidden */
        }

        /* Modal styles */
        .terrain-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .terrain-modal-content {
            background: #333;
            padding: 40px 30px 30px 30px;
            border-radius: 12px;
            min-width: 340px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        /* Button glow effect */
        .btn.glow {
            box-shadow: 0 0 16px 4px #4a9eff, 0 0 4px 2px #fff;
            border-color: #fff;
            outline: 2px solid #4a9eff;
            outline-offset: 0px;
            animation: glowPulse 1s infinite alternate;
        }
        @keyframes glowPulse {
            from { box-shadow: 0 0 16px 4px #4a9eff, 0 0 4px 2px #fff; }
            to   { box-shadow: 0 0 32px 8px #4a9eff, 0 0 8px 4px #fff; }
        }

        /* Add to your <style> section if you want a smooth opacity transition */
        #blendOpacityGroup {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="viewport">
            <canvas id="canvas"></canvas>
            <div id="brushRing"></div>
            <div class="toolbar">
                <button class="btn" id="heightMode">Height Mode</button>
                <button class="btn" id="paintMode">Paint Mode</button>
                <button class="btn" id="smoothMode">Smooth Mode</button>
                <button class="btn" id="resetTerrain">Reset Terrain</button>
                <button class="btn" id="undoAction">Undo</button>
            </div>
            
            <div class="info-panel">
                <div>Mode: <span id="currentMode">Height</span></div>
                <div>Brush Size: <span id="brushSizeDisplay">20</span></div>
                <div>Brush Strength: <span id="brushStrengthDisplay">0.5</span></div>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="section">
                <h3>Terrain Settings</h3>
                <div class="control-group">
                    <label>Terrain Size (Meters): <span id="terrainSizeMeters">1024 x 1024</span></label>
                    <select id="terrainSize">
                        <option value="1024">1024 x 1024</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <h3>Brush Settings</h3>
                <div class="control-group">
                    <label>Brush Size: <span id="brushSizeLabel">20</span></label>
                    <input type="range" id="brushSize" min="1" max="150" value="20">
                </div>
                <div class="control-group">
                    <label>Brush Strength: <span id="brushStrengthLabel">0.5</span></label>
                    <input type="range" id="brushStrength" min="0.1" max="2" step="0.1" value="0.5">
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="protectEdges"> Protect Plane Edges
                    </label>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="invertHeight"> Invert Height (Push Down)
                    </label>
                </div>
                <div class="control-group">
                    <label>Smooth Strength: <span id="smoothStrengthLabel">10</span></label>
                    <input type="range" id="smoothStrength" min="0" max="10" step="0.1" value="10">
                </div>
                <div class="control-group">
                    <label>Brush Falloff: <span id="brushFalloffLabel">100</span></label>
                    <input type="range" id="brushFalloff" min="0" max="100" step="1" value="100">
                </div>
                <!-- Add this under the Brush Falloff control-group, inside Brush Settings section -->
                <div class="control-group">
                    <label style="margin-bottom: 6px; display: block;">Click the square to upload a alpha, or choose one from the dropmenu</label>
                    <select id="presetAlphaSelect" style="width: 100%; margin-bottom: 8px;">
                        <option value="">Select Preset Alpha</option>
                        <option value="alpha1">Alpha 1</option>
                        <option value="alpha2">Alpha 2</option>
                        <option value="alpha3">Alpha 3</option>
                        <option value="alpha4">Alpha 4</option>
                        <option value="alpha5">Alpha 5</option>
                        <option value="alpha6">Alpha 6</option>
                        <option value="alpha7">Alpha 7</option>
                        <option value="alpha8">Alpha 8</option>
                    </select>
                    <div style="display: flex; align-items: center;">
                        <div id="brushAlphaSquare" style="width:60px;height:60px;background:#222;border:2px dashed #4a9eff;display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative;">
                            <span id="brushAlphaPlus" style="font-size:32px;color:#4a9eff;pointer-events:none;">+</span>
                            <img id="brushAlphaPreview" src="" alt="" style="display:none;max-width:100%;max-height:100%;position:absolute;top:0;left:0;">
                            <input type="file" id="brushAlphaInput" accept="image/*" style="display:none;">
                        </div>
                        <button id="removeAlphaBtn" title="Remove alpha" style="margin-left:10px;width:28px;height:28px;background:#444;color:#fff;border:none;border-radius:4px;font-size:20px;cursor:pointer;">−</button>
                    </div>
                    <div style="margin-top:8px;">
                        <label style="font-size:13px;">
                            <input type="checkbox" id="useAlphaCheckbox" checked>
                            Use alpha
                        </label>
                    </div>
                    <div style="margin-top:4px;">
                        <label style="font-size:13px;">
                            <input type="checkbox" id="alphaScaleMode">
                            Alpha Scale mode (drag to scale alpha)
                        </label>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>Texture Painting</h3>
                <button class="btn" id="createTexture">Create Blend Texture Map</button>
                
                <div id="textureControls" style="display: none;">
                    <div class="control-group">
                        <h4 style="margin: 15px 0 10px 0; color: #ccc;">Paint RGB channels</h4>
                        <div class="brush-controls">
                            <div class="brush-btn black active" data-brush="black">
                                <div>Black</div>
                                <small>Base (Grass)</small>
                            </div>
                            <div class="brush-btn red" data-brush="red">
                                <div>Red</div>
                                <small>Layer 1</small>
                            </div>
                            <div class="brush-btn green" data-brush="green">
                                <div>Green</div>
                                <small>Layer 2</small>
                            </div>
                            <div class="brush-btn blue" data-brush="blue">
                                <div>Blue</div>
                                <small>Layer 3</small>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="wireframeToggle"> Show Wireframe
                        </label>
                    </div>

                    <div class="control-group" id="blendOpacityGroup">
                        <label>Blend Map Opacity: <span id="blendOpacityLabel">100%</span></label>
                        <input type="range" id="blendOpacity" min="0" max="100" value="100">
                    </div>

                    <div class="control-group">
                        <h4 style="margin: 15px 0 10px 0; color: #ccc;">Layers</h4>
                        <div class="layer-item">
                            <span class="layer-name">Blend Map</span>
                            <button class="eye-btn" id="toggleBlendMap">👁</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section export-section">
                <h3>Export</h3>
                <button class="btn btn-export" id="exportMesh">Export Mesh (OBJ)</button>
                <button class="btn btn-export" id="exportBlendTexture" disabled>Export Blend Texture (PNG)</button>
            </div>
        </div>
    </div>

    <!-- Texture Size Modal -->
    <div class="texture-size-modal" id="textureSizeModal">
        <div class="modal-content">
            <h3>Select Texture Size</h3>
            <p>Choose the resolution for your blend texture:</p>
            <div class="size-options">
                <div class="size-option" data-size="512">512x512</div>
                <div class="size-option" data-size="1024">1024x1024</div>
                <div class="size-option" data-size="2048">2048x2048</div>
                <div class="size-option" data-size="4096">4096x4096</div>
            </div>
            <button class="btn" id="cancelTextureCreation">Cancel</button>
        </div>
    </div>

    <!-- Terrain Triangle Modal -->
    <div class="terrain-modal" id="terrainModal" style="display: flex;">
        <div class="terrain-modal-content">
            <h3 style="margin-bottom: 20px; color: #4a9eff;">Set terrain triangle amount</h3>
            <div style="margin-bottom: 20px;">
                <input type="range" id="triangleSlider" min="1000" max="300000" step="1000" value="32000" style="width: 100%;">
                <div style="margin-top: 10px; color: #ccc;">
                    <span id="triangleSliderValue">64,000</span> triangles
                </div>
            </div>
            <button class="btn" id="generateTerrainBtn">Generate Terrain</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class TerrainEditor {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.terrain = null;
                this.controls = null;
                
                this.terrainSize = 128;
                this.heightData = null;
                
                this.mode = 'height'; // 'height', 'paint', or 'smooth'
                this.brushSize = 20;
                this.brushStrength = 0.5;
                this.currentBrush = 'black';
                this.invertHeight = false;
                this.smoothStrength = 10; // Default smoothing strength
                this.brushFalloff = 100; // Default falloff (sharp brush)
                
                this.blendTexture = null;
                this.blendCanvas = null;
                this.blendContext = null;
                this.blendTextureSize = 1024;
                this.showBlendMap = true;
                
                this.mouse = { x: 0, y: 0 };
                this.isMouseDown = false;
                this.raycaster = new THREE.Raycaster();
                
                this.history = []; // Stack to store the last 10 changes
                this.maxHistorySize = 10; // Maximum number of changes to store

                this.triangleDensity = null; // In the constructor, set triangleDensity to null so it's not set until user picks

                this.lastPaintPoint = null; // Add this property to your class

                this.protectEdges = true; // <-- Set protectEdges to true by default

                this.isAlphaScaling = false;
                this.alphaDragStart = null;
                this.alphaDragEnd = null;

                this.init();
                this.setupEventListeners();
                document.getElementById('terrainModal').style.display = 'flex';
                this.animate(); // <-- Add this line!
            }
            
            init() {
                const canvas = document.getElementById('canvas');
                
                // Initialize the scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x555555); // Set background to gray

                // Camera setup
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 50, 50);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight); // Add ambient light to the scene
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 0);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight); // Add directional light to the scene
                
                // Simple orbit controls
                this.setupControls();
            }
            
            setupControls() {
                let isDragging = false;
                let isPanning = false;
                let previousMousePosition = { x: 0, y: 0 };

                const canvas = this.renderer.domElement;

                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 1) { // Middle mouse button for panning
                        isPanning = true;
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    } else if (e.button === 2) { // Right click for camera rotation
                        isDragging = true;
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    } else if (e.button === 0) { // Left click for painting
                        this.isMouseDown = true;

                        // Calculate NDC for drag start
                        const rect = canvas.getBoundingClientRect();
                        const ndcStart = {
                            x: ((e.clientX - rect.left) / rect.width) * 2 - 1,
                            y: -((e.clientY - rect.top) / rect.height) * 2 + 1
                        };

                        if (this.mode === 'height' && this.useAlpha && this.alphaScaleMode) {
                            this.isAlphaScaling = true;
                            this.baseBrushStrength = this.brushStrength;
                            this.baseBrushSize = this.brushSize;
                            this.alphaDragStart = ndcStart; // <-- Add this line

                            // Raycast to get world center
                            this.raycaster.setFromCamera(ndcStart, this.camera);
                            const intersects = this.raycaster.intersectObject(this.terrain);
                            if (intersects.length > 0) {
                                this.alphaDragCenter = intersects[0].point.clone();
                            } else {
                                this.isAlphaScaling = false;
                                return;
                            }
                        } else {
                            this.updateMousePosition(e);
                            this.handleTerrainInteraction();
                        }
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (isPanning) {
                        const deltaMove = {
                            x: e.clientX - previousMousePosition.x,
                            y: e.clientY - previousMousePosition.y
                        };

                        const panSpeed = 0.1; // Adjust for sensitivity

                        // Get camera directions
                        const camera = this.camera;
                        const right = new THREE.Vector3();
                        const up = new THREE.Vector3();

                        camera.getWorldDirection(right); // Forward
                        right.cross(camera.up).normalize(); // Right vector
                        up.copy(camera.up).normalize();     // Up vector

                        // Calculate pan offset in world space
                        // Invert deltaMove.y for natural feel (drag up moves up)
                        const panOffset = new THREE.Vector3();
                        panOffset.addScaledVector(right, -deltaMove.x * panSpeed);
                        panOffset.addScaledVector(up, deltaMove.y * panSpeed);

                        // Move camera position and also the look-at target (here, (0,0,0))
                        camera.position.add(panOffset);

                        // If you want to pan the target as well, store a target property:
                        if (!this.cameraTarget) this.cameraTarget = new THREE.Vector3(0, 0, 0);
                        this.cameraTarget.add(panOffset);
                        camera.lookAt(this.cameraTarget);

                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    } else if (isDragging) {
                        const deltaMove = {
                            x: e.clientX - previousMousePosition.x,
                            y: e.clientY - previousMousePosition.y
                        };

                        const spherical = new THREE.Spherical();
                        spherical.setFromVector3(this.camera.position);
                        // Change the rotation speed from 0.01 to 0.005 for slower rotation:
                        const rotationSpeed = 0.005;
                        spherical.theta -= deltaMove.x * rotationSpeed;
                        spherical.phi += deltaMove.y * rotationSpeed;
                        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                        this.camera.position.setFromSpherical(spherical);
                        this.camera.lookAt(0, 0, 0);

                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    } else {
                        this.updateMousePosition(e);
                        if (this.isMouseDown) {
                            // Only allow normal brush action if NOT in alpha scale mode
                            if (!(this.mode === 'height' && this.useAlpha && this.alphaScaleMode && this.isAlphaScaling)) {
                                this.handleTerrainInteraction();
                            }
                        }
                    }

                    // Update drag for alpha scale mode (ZBrush-like: grows from initial click)
                    if (this.isAlphaScaling && this.alphaDragCenter) {
                        const rect = canvas.getBoundingClientRect();
                        const ndc = {
                            x: ((e.clientX - rect.left) / rect.width) * 2 - 1,
                            y: -((e.clientY - rect.top) / rect.height) * 2 + 1
                        };
                        this.alphaDragEnd = ndc; // <-- Add this line

                        this.raycaster.setFromCamera(ndc, this.camera);
                        const intersects = this.raycaster.intersectObject(this.terrain);
                        if (intersects.length > 0) {
                            const dragPoint = intersects[0].point;
                            const dragDist = this.alphaDragCenter.distanceTo(dragPoint);
                            const brushRadius = Math.max(this.baseBrushSize, dragDist);
                            this.brushStrength = this.baseBrushStrength;
                            this.stampAlphaAtWorld(this.alphaDragCenter, brushRadius);
                        }
                    }
                });

                canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 1) {
                        isPanning = false;
                    } else if (e.button === 2) {
                        isDragging = false;
                    } else if (e.button === 0) {
                        this.isMouseDown = false;
                    }

                    if (this.isAlphaScaling) {
                        this.isAlphaScaling = false;

                        // Use the captured NDCs for raycasting
                        this.raycaster.setFromCamera(this.alphaDragStart, this.camera);
                        const startIntersect = this.raycaster.intersectObject(this.terrain);
                        this.raycaster.setFromCamera(this.alphaDragEnd, this.camera);
                        const endIntersect = this.raycaster.intersectObject(this.terrain);

                        if (startIntersect.length > 0 && endIntersect.length > 0) {
                            const startPt = startIntersect[0].point;
                            const endPt = endIntersect[0].point;
                            // Center is midpoint
                            const centerPt = new THREE.Vector3().addVectors(startPt, endPt).multiplyScalar(0.5);
                            // Scale is the largest distance in X or Z (for a square alpha)
                            const scale = Math.max(Math.abs(endPt.x - startPt.x), Math.abs(endPt.z - startPt.z)) * 0.5; // half-size for radius
                            this.stampAlphaAtWorld(centerPt, scale);
                        }
                    }
                });

                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const distance = this.camera.position.length();
                    const newDistance = Math.max(10, Math.min(200, distance + e.deltaY * 0.1));
                    this.camera.position.normalize().multiplyScalar(newDistance);
                });

                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            // Update updateMousePosition to project the lastPaintPoint if available:
            updateMousePosition(e) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                // Update brush ring position and size to follow the mouse
                const brushRing = document.getElementById('brushRing');
                const ringSize = this.brushSize;
                brushRing.style.left = `${e.clientX - ringSize / 2}px`;
                brushRing.style.top = `${e.clientY - ringSize / 2}px`;
                brushRing.style.width = `${ringSize}px`;
                brushRing.style.height = `${ringSize}px`;
            }
            
            handleTerrainInteraction() {
                if (!this.terrain) return;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.terrain);
                
                if (intersects.length > 0) {
                    const intersection = intersects[0];
                    const point = intersection.point;
                    this.lastPaintPoint = point; // Store for ring update

                    if (this.mode === 'height') {
                        this.modifyHeight(point);
                    } else if (this.mode === 'paint' && this.blendCanvas) {
                        this.paintTexture(point);
                    } else if (this.mode === 'smooth') {
                        this.smoothTerrain(point);
                    }
                }
            }
            
            modifyHeight(point) {
                // Save current state to history before modifying
                this.saveHistory();

                const geometry = this.terrain.geometry;
                const vertices = geometry.attributes.position;
                const size = this.triangleDensity;
            
                // Convert world position to terrain coordinates
                const terrainX = Math.floor((point.x + this.terrainSize / 2) / this.terrainSize * size);
                const terrainZ = Math.floor((point.z + this.terrainSize / 2) / this.terrainSize * size);
            
                const brushRadius = this.brushSize;
                const heightModifier = this.invertHeight ? -this.brushStrength : this.brushStrength;
            
                for (let x = -brushRadius; x <= brushRadius; x++) {
                    for (let z = -brushRadius; z <= brushRadius; z++) {
                        const currentX = terrainX + x;
                        const currentZ = terrainZ + z;

                        // Skip vertices outside the terrain bounds
                        if (currentX < 0 || currentX >= size || currentZ < 0 || currentZ >= size) continue;

                        // Skip edge vertices if "Protect Plane Edges" is enabled
                        if (this.protectEdges && (currentX === 0 || currentX === size - 1 || currentZ === 0 || currentZ === size - 1)) {
                            continue;
                        }

                        const distance = Math.sqrt(x * x + z * z);
                        if (distance <= brushRadius) {
                            // --- Alpha mask support ---
                            let alphaFactor = 1;
                            if (this.useAlpha && this.brushAlpha) {
                                // Map (x, z) in brush space to alpha image space
                                const alphaData = this.brushAlpha;
                                const alphaW = alphaData.width;
                                const alphaH = alphaData.height;
                                // Normalize to [0,1]
                                const u = (x + brushRadius) / (2 * brushRadius);
                                const v = (z + brushRadius) / (2 * brushRadius);
                                // Get pixel in alpha image
                                const px = Math.floor(u * (alphaW - 1));
                                const py = Math.floor(v * (alphaH - 1));
                                const idx = (py * alphaW + px) * 4;
                                const r = alphaData.data[idx];
                                const g = alphaData.data[idx + 1];
                                const b = alphaData.data[idx + 2];
                                const a = alphaData.data[idx + 3];
                                const gray = (r + g + b) / 3;
                                // Only affect if pixel is light and not transparent
                                alphaFactor = (a > 0 && gray > 128) ? (gray / 255) : 0;
                                if (alphaFactor === 0) continue; // Skip if masked out
                            }
                            // --- End alpha mask support ---

                            const falloff = Math.pow(1 - (distance / brushRadius), this.brushFalloff / 100);
                            const vertexIndex = currentZ * size + currentX;

                            if (vertexIndex < vertices.count) {
                                const currentHeight = vertices.getY(vertexIndex);
                                const targetHeight = currentHeight + heightModifier * falloff * alphaFactor;
                                vertices.setY(vertexIndex, targetHeight);

                                // Update height data
                                if (this.heightData) {
                                    this.heightData[vertexIndex] = targetHeight;
                                }
                            }
                        }
                    }
                }
            
                vertices.needsUpdate = true;
                geometry.computeVertexNormals();
            }
            
            paintTexture(point) {
                if (!this.blendContext) return;

                // Save current state to history
                this.saveHistory();

                const size = this.terrainSize; // Use the physical size of the terrain
                const textureSize = this.blendTextureSize;

                // Convert world position to texture coordinates (UVs)
                const u = (point.x + size / 2) / size;
                const v = (point.z + size / 2) / size; // No flip

                const textureX = u * textureSize;
                const textureY = v * textureSize;

                const brushRadius = (this.brushSize / size) * textureSize;

                // Set blend mode for clean color painting
                this.blendContext.globalCompositeOperation = 'source-over';

                let brushColor;
                switch (this.currentBrush) {
                    case 'black':
                        brushColor = `rgba(0, 0, 0, 1)`;
                        break;
                    case 'red':
                        brushColor = `rgba(255, 0, 0, 1)`;
                        break;
                    case 'green':
                        brushColor = `rgba(0, 255, 0, 1)`;
                        break;
                    case 'blue':
                        brushColor = `rgba(0, 0, 255, 1)`;
                        break;
                }

                // Create clean brush with proper falloff
                const gradient = this.blendContext.createRadialGradient(
                    textureX, textureY, 0,
                    textureX, textureY, brushRadius
                );

                // For pure color painting without black artifacts
                const baseColor = brushColor.replace('1)', `${this.brushStrength})`);
                const fadeColor = brushColor.replace('1)', '0)');

                const falloffFactor = this.brushFalloff / 100;
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(falloffFactor, fadeColor);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                this.blendContext.fillStyle = gradient;
                this.blendContext.beginPath();
                this.blendContext.arc(textureX, textureY, brushRadius, 0, Math.PI * 2);
                this.blendContext.fill();

                // Apply the alpha if enabled
                if (this.useAlpha && this.brushAlpha) {
                    // Prepare an offscreen canvas for the alpha mask if not already done
                    if (!this.brushAlphaCanvas) {
                        this.brushAlphaCanvas = document.createElement('canvas');
                    }
                    const alphaData = this.brushAlpha;
                    this.brushAlphaCanvas.width = 2 * brushRadius;
                    this.brushAlphaCanvas.height = 2 * brushRadius;
                    const alphaCtx = this.brushAlphaCanvas.getContext('2d');
                    alphaCtx.clearRect(0, 0, this.brushAlphaCanvas.width, this.brushAlphaCanvas.height);

                    // Draw the alpha mask, scaled to the brush size
                    // 1. Draw the grayscale image scaled to the brush size
                    // 2. Get the image data and set the alpha channel to the grayscale value
                    // 3. Put the new image data back

                    // Step 1: Draw grayscale image scaled
                    const temp = document.createElement('canvas');
                    temp.width = alphaData.width;
                    temp.height = alphaData.height;
                    temp.getContext('2d').putImageData(alphaData, 0, 0);
                    alphaCtx.drawImage(temp, 0, 0, alphaData.width, alphaData.height, 0, 0, 2 * brushRadius, 2 * brushRadius);

                    // Step 2: Convert grayscale to alpha
                    const imgData = alphaCtx.getImageData(0, 0, 2 * brushRadius, 2 * brushRadius);
                    for (let i = 0; i < imgData.data.length; i += 4) {
                        // Use the average of R,G,B as alpha
                        const gray = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
                        imgData.data[i + 3] = gray;
                        // Optionally, set RGB to 255 for a clean mask (not required)
                        imgData.data[i] = 255;
                        imgData.data[i + 1] = 255;
                        imgData.data[i + 2] = 255;
                    }
                    alphaCtx.putImageData(imgData, 0, 0);

                    // Step 3: Fill with brush color using source-in
                    alphaCtx.globalCompositeOperation = 'source-in';
                    alphaCtx.fillStyle = brushColor.replace('1)', `${this.brushStrength})`);
                    alphaCtx.fillRect(0, 0, 2 * brushRadius, 2 * brushRadius);

                    // Stamp the result onto the blend canvas
                    this.blendContext.save();
                    this.blendContext.globalAlpha = 1.0;
                    this.blendContext.globalCompositeOperation = 'source-over';
                    this.blendContext.drawImage(
                        this.brushAlphaCanvas,
                        0, 0, 2 * brushRadius, 2 * brushRadius,
                        textureX - brushRadius, textureY - brushRadius,
                        2 * brushRadius, 2 * brushRadius
                    );
                    this.blendContext.restore();
                } else {
                    // ...existing radial gradient brush code...
                }

                // Update texture
                this.blendTexture.needsUpdate = true;
            }
            
            smoothTerrain(point) {
                const geometry = this.terrain.geometry;
                const vertices = geometry.attributes.position;
                const size = this.triangleDensity;
            
                // Convert world position to terrain coordinates
                const terrainX = Math.floor((point.x + this.terrainSize / 2) / this.terrainSize * size);
                const terrainZ = Math.floor((point.z + this.terrainSize / 2) / this.terrainSize * size);
            
                const brushRadius = this.brushSize;
                const smoothingStrength = this.smoothStrength * 0.1; // Scale slider value
            
                for (let x = -brushRadius; x <= brushRadius; x++) {
                    for (let z = -brushRadius; z <= brushRadius; z++) {
                        const currentX = terrainX + x;
                        const currentZ = terrainZ + z;
            
                        if (currentX >= 1 && currentX < size - 1 && currentZ >= 1 && currentZ < size - 1) {
                            const distance = Math.sqrt(x * x + z * z);
                            if (distance <= brushRadius) {
                                const falloff = 1 - (distance / brushRadius);
                                const vertexIndex = currentZ * size + currentX;
            
                                if (vertexIndex < vertices.count) {
                                    // Get surrounding heights for averaging
                                    const heights = [];
                                    for (let dx = -1; dx <= 1; dx++) {
                                        for (let dz = -1; dz <= 1; dz++) {
                                            const neighborIndex = (currentZ + dz) * size + (currentX + dx);
                                            if (neighborIndex >= 0 && neighborIndex < vertices.count) {
                                                heights.push(vertices.getY(neighborIndex));
                                            }
                                        }
                                    }
            
                                    // Calculate average height
                                    const averageHeight = heights.reduce((sum, h) => sum + h, 0) / heights.length;
                                    const currentHeight = vertices.getY(vertexIndex);
            
                                    // Smooth towards average
                                    const smoothedHeight = currentHeight + (averageHeight - currentHeight) * smoothingStrength * falloff;
                                    vertices.setY(vertexIndex, smoothedHeight);
            
                                    // Update height data
                                    if (this.heightData) {
                                        this.heightData[vertexIndex] = smoothedHeight;
                                    }
                                }
                            }
                        }
                    }
                }
            
                vertices.needsUpdate = true;
                geometry.computeVertexNormals();
            }
            
            createBlendTexture(size) {
                this.blendTextureSize = size;
                
                // Create canvas for blend texture
                this.blendCanvas = document.createElement('canvas');
                this.blendCanvas.width = size;
                this.blendCanvas.height = size;
                this.blendContext = this.blendCanvas.getContext('2d');
                
                // Fill with black (base texture)
                this.blendContext.fillStyle = '#000000';
                this.blendContext.fillRect(0, 0, size, size);
                
                // Create Three.js texture
                if (this.blendTexture) {
                    this.blendTexture.dispose();
                }
                this.blendTexture = new THREE.CanvasTexture(this.blendCanvas);
                this.blendTexture.flipY = false;
                
                // Update terrain material to show blend texture if enabled
                if (this.showBlendMap && this.terrain) {
                    this.terrain.material.map = this.blendTexture;
                    this.terrain.material.needsUpdate = true;
                }
                
                // Enable texture controls
                document.getElementById('textureControls').style.display = 'block';
                document.getElementById('exportBlendTexture').disabled = false;
            }
            
            toggleBlendMapVisibility() {
                this.showBlendMap = !this.showBlendMap;

                if (this.terrain) {
                    if (this.showBlendMap && this.blendTexture) {
                        this.terrain.material.map = this.blendTexture;
                    } else {
                        this.terrain.material.map = null;
                    }
                    this.terrain.material.needsUpdate = true;
                }

                const eyeBtn = document.getElementById('toggleBlendMap');
                eyeBtn.textContent = this.showBlendMap ? '👁' : '👁‍🗨';
                eyeBtn.classList.toggle('hidden', !this.showBlendMap);
            }
            
            exportMesh() {
                if (!this.terrain) return;

                if (confirm("Ready to export the model?")) {
                    const geometry = this.terrain.geometry;
                    const vertices = geometry.attributes.position;
                    const uvs = geometry.attributes.uv;
                    const normals = geometry.attributes.normal;
                    const indices = geometry.index;

                    let objContent = '# Terrain OBJ Export\n';

                    // Export vertices (convert meters to centimeters)
                    for (let i = 0; i < vertices.count; i++) {
                        const x = vertices.getX(i) * 100;
                        const y = vertices.getY(i) * 100;
                        const z = vertices.getZ(i) * 100;
                        objContent += `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`;
                    }

                    // Export UVs
                    for (let i = 0; i < uvs.count; i++) {
                        const u = uvs.getX(i);
                        const v = uvs.getY(i);
                        objContent += `vt ${u.toFixed(6)} ${v.toFixed(6)}\n`;
                    }

                    // Export normals (smooth/soften edge)
                    for (let i = 0; i < normals.count; i++) {
                        const nx = normals.getX(i);
                        const ny = normals.getY(i);
                        const nz = normals.getZ(i);
                        objContent += `vn ${nx.toFixed(6)} ${ny.toFixed(6)} ${nz.toFixed(6)}\n`;
                    }

                    // Export faces (with UV and normal indices)
                    if (indices) {
                        for (let i = 0; i < indices.count; i += 3) {
                            // OBJ indices start at 1
                            const a = indices.getX(i) + 1;
                            const b = indices.getX(i + 1) + 1;
                            const c = indices.getX(i + 2) + 1;
                            objContent += `f ${a}/${a}/${a} ${b}/${b}/${b} ${c}/${c}/${c}\n`;
                        }
                    }

                    const blob = new Blob([objContent], { type: 'text/plain' });
                    const link = document.createElement('a');
                    link.download = 'terrain.obj';
                    link.href = URL.createObjectURL(blob);
                    link.click();
                }
            }
            
            exportBlendTexture() {
                if (!this.blendCanvas) return;
                
                const link = document.createElement('a');
                link.download = 'blend_texture.png';
                link.href = this.blendCanvas.toDataURL();
                link.click();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.renderer.render(this.scene, this.camera);
            }
            
            setupEventListeners() {
                // Mode switching
                document.getElementById('heightMode').addEventListener('click', () => {
                    this.mode = 'height';
                    document.getElementById('currentMode').textContent = 'Height';
                    document.querySelectorAll('.toolbar .btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('heightMode').classList.add('active');

                    // Show brush ring
                    document.getElementById('brushRing').style.display = 'block';
                });
                
                document.getElementById('paintMode').addEventListener('click', () => {
                    this.mode = 'paint';
                    document.getElementById('currentMode').textContent = 'Paint';
                    document.querySelectorAll('.toolbar .btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('paintMode').classList.add('active');

                    // Show brush ring
                    document.getElementById('brushRing').style.display = 'block';
                });
                
                document.getElementById('smoothMode').addEventListener('click', () => {
                    this.mode = 'smooth';
                    document.getElementById('currentMode').textContent = 'Smooth';
                    document.querySelectorAll('.toolbar .btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('smoothMode').classList.add('active');

                    // Show brush ring
                    document.getElementById('brushRing').style.display = 'block';
                });
                
                // Hide brush ring when switching to other modes
                document.getElementById('resetTerrain').addEventListener('click', () => {
                    // Clear blend map if it exists
                    if (this.blendContext && this.blendCanvas) {
                        this.blendContext.fillStyle = '#000000';
                        this.blendContext.fillRect(0, 0, this.blendCanvas.width, this.blendCanvas.height);
                        if (this.blendTexture) this.blendTexture.needsUpdate = true;
                    }
                    // Hide paint controls, show only "Create Blend Texture Map" button
                    document.getElementById('textureControls').style.display = 'none';
                    document.getElementById('createTexture').style.display = 'block';
                    document.getElementById('exportBlendTexture').disabled = true;
                    document.getElementById('brushRing').style.display = 'none';
                    this.generateTerrain();
                });
                
                // Ensure the brush ring is visible by default in height mode
                document.getElementById('brushRing').style.display = 'block';

                // Terrain settings
                document.getElementById('terrainSize').addEventListener('change', (e) => {
                    this.terrainSize = parseInt(e.target.value);
                    document.getElementById('terrainSizeMeters').textContent = `${this.terrainSize} x ${this.terrainSize}`;
                });
                
                document.getElementById('wireframeToggle').addEventListener('change', (e) => {
                    if (this.terrain) {
                        this.terrain.material.wireframe = e.target.checked;
                    }
                });
                
                document.getElementById('resetTerrain').addEventListener('click', () => {
                    // Clear blend map if it exists
                    if (this.blendContext && this.blendCanvas) {
                        this.blendContext.fillStyle = '#000000';
                        this.blendContext.fillRect(0, 0, this.blendCanvas.width, this.blendCanvas.height);
                        if (this.blendTexture) this.blendTexture.needsUpdate = true;
                    }
                    // Hide paint controls, show only "Create Blend Texture Map" button
                    document.getElementById('textureControls').style.display = 'none';
                    document.getElementById('createTexture').style.display = 'block';
                    document.getElementById('exportBlendTexture').disabled = true;
                    document.getElementById('brushRing').style.display = 'none';
                    this.generateTerrain();
                });
                
                // Brush settings
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushSizeLabel').textContent = e.target.value;
                    document.getElementById('brushSizeDisplay').textContent = e.target.value;

                    // Update the brush ring size immediately
                    const brushRing = document.getElementById('brushRing');
                    brushRing.style.width = `${this.brushSize}px`;
                    brushRing.style.height = `${this.brushSize}px`;
                });
                
                document.getElementById('brushStrength').addEventListener('input', (e) => {
                    this.brushStrength = parseFloat(e.target.value);
                    document.getElementById('brushStrengthLabel').textContent = e.target.value;
                    document.getElementById('brushStrengthDisplay').textContent = e.target.value;
                });
                
                document.getElementById('invertHeight').addEventListener('change', (e) => {
                    this.invertHeight = e.target.checked;
                });
                
                document.getElementById('smoothStrength').addEventListener('input', (e) => {
                    this.smoothStrength = parseFloat(e.target.value);
                    document.getElementById('smoothStrengthLabel').textContent = e.target.value;
                });

                document.getElementById('brushFalloff').addEventListener('input', (e) => {
                    this.brushFalloff = parseInt(e.target.value);
                    document.getElementById('brushFalloffLabel').textContent = e.target.value;
                });
                
                // Texture creation
                document.getElementById('createTexture').addEventListener('click', () => {
                    document.getElementById('textureSizeModal').style.display = 'flex';

                    // Switch to paint mode
                    this.mode = 'paint';
                    document.getElementById('currentMode').textContent = 'Paint';
                    document.querySelectorAll('.toolbar .btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('paintMode').classList.add('active');
                });
                
                document.getElementById('cancelTextureCreation').addEventListener('click', () => {
                    document.getElementById('textureSizeModal').style.display = 'none';
                });
                
                // Texture size selection
                document.querySelectorAll('.size-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const size = parseInt(option.dataset.size);
                        this.createBlendTexture(size);
                        document.getElementById('textureSizeModal').style.display = 'none';
                    });
                });
                
                // Brush selection
                document.querySelectorAll('.brush-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentBrush = btn.dataset.brush;
                    });
                });
                
                // Layer visibility toggle
                document.getElementById('toggleBlendMap').addEventListener('click', () => {
                    this.toggleBlendMapVisibility();
                });
                
                document.getElementById('exportMesh').addEventListener('click', () => {
                    this.exportMesh();
                });
                
                document.getElementById('exportBlendTexture').addEventListener('click', () => {
                    this.exportBlendTexture();
                });

                document.getElementById('protectEdges').addEventListener('change', (e) => {
                    this.protectEdges = e.target.checked;
                });
                document.getElementById('protectEdges').checked = true;
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Prevent context menu on canvas
                document.getElementById('canvas').addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Initialize mode button states
                document.getElementById('heightMode').classList.add('active');
                document.getElementById('brushRing').style.display = 'block';

                // Undo action
                document.getElementById('undoAction').addEventListener('click', () => {
                    this.undo();
                });

                // Modal slider update
                const triangleSlider = document.getElementById('triangleSlider');
                const triangleSliderValue = document.getElementById('triangleSliderValue');
                if (triangleSlider && triangleSliderValue) {
                    triangleSlider.addEventListener('input', () => {
                        triangleSliderValue.textContent = parseInt(triangleSlider.value).toLocaleString();
                    });
                }

                // Generate terrain from modal
                const terrainModal = document.getElementById('terrainModal');
                const generateTerrainBtn = document.getElementById('generateTerrainBtn');
                if (generateTerrainBtn && triangleSlider && terrainModal) {
                    generateTerrainBtn.addEventListener('click', () => {
                        // Calculate segments from triangle count: triangles = 2 * segments^2 => segments = sqrt(triangles/2)
                        const triangleCount = parseInt(triangleSlider.value);
                        const segments = Math.max(1, Math.round(Math.sqrt(triangleCount / 2)));
                        this.triangleDensity = segments + 1; // triangleDensity = segments + 1

                        // Hide modal and generate terrain
                        terrainModal.style.display = 'none';
                        this.generateTerrain();
                    });
                }

                const createTextureBtn = document.getElementById('createTexture');

                // Highlight "Create Blend Texture Map" when entering paint mode
                document.getElementById('paintMode').addEventListener('click', () => {
                    if (createTextureBtn && !createTextureBtn.classList.contains('glow')) {
                        createTextureBtn.classList.add('glow');
                    }
                });

                // Remove highlight when the button is pressed
                createTextureBtn.addEventListener('click', () => {
                    createTextureBtn.classList.remove('glow');
                });

                // Blend map opacity control
                const blendOpacitySlider = document.getElementById('blendOpacity');
                const blendOpacityLabel = document.getElementById('blendOpacityLabel');
                if (blendOpacitySlider && blendOpacityLabel) {
                    blendOpacitySlider.addEventListener('input', () => {
                        const value = parseInt(blendOpacitySlider.value);
                        blendOpacityLabel.textContent = value + '%';
                        // Set blend map opacity on the terrain material
                        if (this.terrain && this.terrain.material && this.terrain.material.map) {
                            this.terrain.material.transparent = value < 100;
                            this.terrain.material.opacity = value / 100;
                            this.terrain.material.needsUpdate = true;
                        }
                    });
                }

                // Brush alpha image logic
                this.brushAlpha = null; // Store the loaded alpha image (as ImageData)
                this.useAlpha = true;

                const brushAlphaSquare = document.getElementById('brushAlphaSquare');
                const brushAlphaInput = document.getElementById('brushAlphaInput');
                const brushAlphaPreview = document.getElementById('brushAlphaPreview');
                const brushAlphaPlus = document.getElementById('brushAlphaPlus');
                const removeAlphaBtn = document.getElementById('removeAlphaBtn');
                const useAlphaCheckbox = document.getElementById('useAlphaCheckbox');

                // Open file dialog on square click
                brushAlphaSquare.addEventListener('click', () => {
                    brushAlphaInput.click();
                });

                // Load and preview the alpha image
                brushAlphaInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    // Clear dropdown selection
                    presetAlphaSelect.value = "";

                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new window.Image();
                        img.onload = () => {
                            // Draw image to canvas to get grayscale data
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            const imageData = ctx.getImageData(0, 0, img.width, img.height);
                            // Store as brush alpha
                            this.brushAlpha = imageData;
                            // Show preview (thumbnail) under the + sign
                            brushAlphaPreview.src = canvas.toDataURL();
                            brushAlphaPreview.style.display = 'block';
                            brushAlphaPlus.style.display = 'none';
                        };
                        img.src = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                });

                // Remove alpha
                removeAlphaBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.brushAlpha = null;
                    brushAlphaPreview.src = '';
                    brushAlphaPreview.style.display = 'none';
                    brushAlphaPlus.style.display = 'block';
                    brushAlphaInput.value = '';
                    presetAlphaSelect.value = "";
                });

                // Use alpha checkbox
                useAlphaCheckbox.addEventListener('change', (e) => {
                    this.useAlpha = e.target.checked;
                });
const alphaScaleModeCheckbox = document.getElementById('alphaScaleMode');
this.alphaScaleMode = false;
alphaScaleModeCheckbox.addEventListener('change', (e) => {
    this.alphaScaleMode = e.target.checked;
});
                const presetAlphaSelect = document.getElementById('presetAlphaSelect');
const presetAlphaLinks = {
    alpha1: "https://raw.githubusercontent.com/kindland/SanTerrainSplatmap/main/alpha1.png", // e.g. "https://yourgithub.io/alpha1.png"
    alpha2: "https://raw.githubusercontent.com/kindland/SanTerrainSplatmap/main/alpha2.png",
    alpha3: "https://raw.githubusercontent.com/kindland/SanTerrainSplatmap/main/alpha3.png",
    alpha4: "https://raw.githubusercontent.com/kindland/SanTerrainSplatmap/main/alpha4.png",
    alpha5: "https://raw.githubusercontent.com/kindland/SanTerrainSplatmap/main/alpha5.png",
    alpha6: "https://raw.githubusercontent.com/kindland/SanTerrainSplatmap/main/alpha6.png",
    alpha7: "https://raw.githubusercontent.com/kindland/SanTerrainSplatmap/main/alpha7.png",
    alpha8: "https://raw.githubusercontent.com/kindland/SanTerrainSplatmap/main/alpha8.png"
};

presetAlphaSelect.addEventListener('change', () => {
    const key = presetAlphaSelect.value;
    if (!key) return;

    // Always clear uploaded alpha and preview
    this.brushAlpha = null;
    brushAlphaInput.value = '';

    // Load the selected preset alpha image
    const url = presetAlphaLinks[key];
    if (!url) return;

    const img = new window.Image();
    img.crossOrigin = "anonymous"; // Allow loading from GitHub
    img.onload = () => {
        // Draw image to canvas to get grayscale data
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        // Store as brush alpha
        this.brushAlpha = imageData;
        // Show preview (thumbnail) under the + sign
        brushAlphaPreview.src = canvas.toDataURL();
        brushAlphaPreview.style.display = 'block';
        brushAlphaPlus.style.display = 'none';
    };
    img.src = url;
});
            }

            modifyHeightWithAlpha(point, brushSizeWorld) {
                // Save current state to history before modifying
                this.saveHistory();

                const geometry = this.terrain.geometry;
                const vertices = geometry.attributes.position;
                const size = this.triangleDensity;

                // Convert world position to terrain grid coordinates
                const terrainX = Math.floor((point.x + this.terrainSize / 2) / this.terrainSize * size);
                const terrainZ = Math.floor((point.z + this.terrainSize / 2) / this.terrainSize * size);

                // Convert world brush size (meters) to grid units
                const brushRadius = Math.max(1, Math.round(brushSizeWorld / this.terrainSize * size));

                const heightModifier = this.invertHeight ? -this.brushStrength : this.brushStrength;
            
                for (let x = -brushRadius; x <= brushRadius; x++) {
                    for (let z = -brushRadius; z <= brushRadius; z++) {
                        const currentX = terrainX + x;
                        const currentZ = terrainZ + z;

                        // Skip vertices outside the terrain bounds
                        if (currentX < 0 || currentX >= size || currentZ < 0 || currentZ >= size) continue;

                        // Skip edge vertices if "Protect Plane Edges" is enabled
                        if (this.protectEdges && (currentX === 0 || currentX === size - 1 || currentZ === 0 || currentZ === size - 1)) {
                            continue;
                        }

                        const distance = Math.sqrt(x * x + z * z);
                        if (distance <= brushRadius) {
                            // --- Alpha mask support ---
                            let alphaFactor = 1;
                            if (this.useAlpha && this.brushAlpha) {
                                // Map (x, z) in brush space to alpha image space
                                const alphaData = this.brushAlpha;
                                const alphaW = alphaData.width;
                                const alphaH = alphaData.height;
                                // Normalize to [0,1]
                                const u = (x + brushRadius) / (2 * brushRadius);
                                const v = (z + brushRadius) / (2 * brushRadius);
                                // Get pixel in alpha image
                                const px = Math.floor(u * (alphaW - 1));
                                const py = Math.floor(v * (alphaH - 1));
                                const idx = (py * alphaW + px) * 4;
                                const r = alphaData.data[idx];
                                const g = alphaData.data[idx + 1];
                                const b = alphaData.data[idx + 2];
                                const a = alphaData.data[idx + 3];
                                const gray = (r + g + b) / 3;
                                // Only affect if pixel is light and not transparent
                                alphaFactor = (a > 0 && gray > 128) ? (gray / 255) : 0;
                                if (alphaFactor === 0) continue; // Skip if masked out
                            }
                            // --- End alpha mask support ---

                            const falloff = Math.pow(1 - (distance / brushRadius), this.brushFalloff / 100);
                            const vertexIndex = currentZ * size + currentX;

                            if (vertexIndex < vertices.count) {
                                const currentHeight = vertices.getY(vertexIndex);
                                const targetHeight = currentHeight + heightModifier * falloff * alphaFactor;
                                vertices.setY(vertexIndex, targetHeight);

                                // Update height data
                                if (this.heightData) {
                                    this.heightData[vertexIndex] = targetHeight;
                                }
                            }
                        }
                    }
                }
            
                vertices.needsUpdate = true;
                geometry.computeVertexNormals();
            }
            
            generateTerrain() {
                if (this.triangleDensity == null) return;

                // Remove existing terrain if present
                if (this.terrain) {
                    this.scene.remove(this.terrain);
                    this.terrain.geometry.dispose();
                    this.terrain.material.dispose();
                    this.terrain = null;
                }

                // Use the terrain size from the dropdown or default to 1024
                const size = this.terrainSize || 1024;
                const segments = this.triangleDensity - 1;

                // Create geometry
                const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
                geometry.rotateX(-Math.PI / 2);

                // --- Create UVs ---
                // Map X,Z coordinates to [0,1] UV space
                const uvs = [];
                for (let i = 0; i < geometry.attributes.position.count; i++) {
                    const x = geometry.attributes.position.getX(i);
                    const z = geometry.attributes.position.getZ(i);
                    // Convert from world coordinates to [0,1]
                    const u = (x + size / 2) / size;
                    const v = (z + size / 2) / size;
                    uvs.push(u, v);
                }
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                // --- End UVs ---

                // Set all heights to 0 (flat)
                this.heightData = new Float32Array(this.triangleDensity * this.triangleDensity);
                const vertices = geometry.attributes.position;
                for (let i = 0; i < vertices.count; i++) {
                    vertices.setY(i, 0);
                    this.heightData[i] = 0;
                }
                geometry.computeVertexNormals();

                // Soft green color
                const material = new THREE.MeshLambertMaterial({
                    color: 0x90ee90, // soft green
                    wireframe: false
                });

                this.terrain = new THREE.Mesh(geometry, material);
                this.terrain.receiveShadow = true;
                this.scene.add(this.terrain);

                // Optionally, move the camera up and back if terrain is large
                this.camera.position.set(0, size * 0.7, size * 0.7);
                this.camera.lookAt(0, 0, 0);
            }
            
            saveHistory() {
                // Limit history size
                if (this.history.length >= this.maxHistorySize) {
                    this.history.shift(); // Remove the oldest entry
                }

                // Save current height data and blend texture
                const heightDataCopy = new Float32Array(this.heightData);
                const blendTextureCopy = this.blendCanvas ? this.blendCanvas.toDataURL() : null;

                this.history.push({
                    heightData: heightDataCopy,
                    blendTexture: blendTextureCopy
                });
            }

            undo() {
                if (this.history.length === 0) return; // No history to undo

                const lastState = this.history.pop();

                // Restore height data
                this.heightData = lastState.heightData;
                const vertices = this.terrain.geometry.attributes.position;
                for (let i = 0; i < this.heightData.length; i++) {
                    vertices.setY(i, this.heightData[i]);
                }
                vertices.needsUpdate = true;
                this.terrain.geometry.computeVertexNormals();

                // Restore blend texture
                if (lastState.blendTexture && this.blendCanvas) {
                    const img = new Image();
                    img.onload = () => {
                        this.blendContext.clearRect(0, 0, this.blendCanvas.width, this.blendCanvas.height);
                        this.blendContext.drawImage(img, 0, 0);
                        this.blendTexture.needsUpdate = true;
                    };
                    img.src = lastState.blendTexture;
                }
            }

            stampAlphaAt(screenX, screenY, scale) {
                // Convert screenX, screenY to world position using raycaster
                this.raycaster.setFromCamera({ x: screenX, y: screenY }, this.camera);
                const intersects = this.raycaster.intersectObject(this.terrain);
                if (intersects.length === 0) return;
                const point = intersects[0].point;

                // Use the scale to determine the brush size for the alpha
                const brushSize = scale * this.terrainSize; // Adjust as needed

                // Now use your existing alpha painting logic, but with brushSize
                // For example, call this.modifyHeight(point, brushSize);
                this.modifyHeightWithAlpha(point, brushSize);
            }

            stampAlphaAtWorld(worldPoint, brushSize) {
                // Use your alpha painting logic, but with a custom center and brushSize
                this.modifyHeightWithAlpha(worldPoint, brushSize);
            }

        }
        
        // Initialize the terrain editor when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            new TerrainEditor();
        });
    </script>
</body>
</html>